package edu.cnm.deepdive.craps.models;

import java.util.LinkedList;
import java.util.List;
import java.util.Random;

/**
 * A class that simulates a Monte Carlo style simulation of Craps, it simulates a single player
 * employing either a single or multiple plays. I has a run feature that can be left over  long
 * period of time to see the amount of wins over the times played and outputs a percentage of those
 * simulations.
 */
public class Craps {


  private State state = State.COME_OUT;
  private Random rng = new Random();
  private List<int[]> rolls = new LinkedList<>();

  /**
   * Employs a linked list to track the outcome of each roll into an array so that outcome can be
   * displayed to the user.
   *
   * @return                       returns a copied tally list of the rolls so as to display
   */
  public List<int[]> getRolls() {
    List<int[]> copy = new LinkedList<>(rolls);
    return copy;
  }

  /**
   * Allows the user to reset the tracked rolls.
   */
  protected void reset() {
    state = State.COME_OUT;
    rolls.clear();
  }

  /**
   * Continues rolling the dice while the current state is in the <code>POINT</code> state.
   * @return                  The state of the game
   */
  public State play() {
    reset();
    do {
      roll();
    } while  (state == State.POINT);
    return state;
  }

  /**
   * Rolls 2 separate 6 sided dice by invoking [@link Random] then adds the dice together
   * and returns the sum of the dice.
   *
   * @return                     Returns the sum of the dice generated by Random
   */
  protected int roll() {
    int[] dice = {
      1 + rng.nextInt(6),
      1 + rng.nextInt(6),
    };
    int sum = dice[0] + dice[1];
    rolls.add(dice);
    state = state.roll(sum);
    return sum;
  }

  /**
   * Gathers the information of the current state of the game and returns it.
   *
   * @return                      Returns the state of the game.
   */
  public State getState() {
    return state;
  }

  /**
   * Enums set to solidify the state the game is currently in. <code>COME_OUT</code> to start the game,
   * <code>WIN</code> and <code>LOSS</code> states whether the game ended in a win or a loss
   * <code>POINT</code> if currently still rolling the dice.
   */
  public enum State {
  COME_OUT, WIN, LOSS, POINT, TERMINAL;

  private int point = 0;

    /**
     * Employs a switch statement to implement the rules of the game. Returns the state of the
     * game for the correct scenario. If on the <code>COME_OUT</code> a 2, 3, or 12 are rolled
     * the switch returns a <code>LOSS</code>, if 7 or 11 <code>WIN</code> is returned. Otherwise
     * <code>POINT</code> is returned which then employs another switch that rolls until either the
     * original number which returns a win or a 7 is rolled which returns a loss.
     *
     * @param diceSum                    The sum of the number when the dice is rolled to be checked
     *                                   by the switch to decide which state to return.
     * @return                           WIN or LOSS in the scenarios mentioned above.
     */
  public State roll(int diceSum) {
    switch (this) {
      case COME_OUT:
      switch (diceSum) {
        case 2:
        case 3:
        case 12:
          return LOSS;
        case 7:
        case 11:
          return WIN;
        default:
          POINT.point = diceSum;
          return POINT;
      }
      case POINT:
        if (diceSum == point) {
          return WIN;
        } else if (diceSum == 7) {
          return LOSS;
        } else {
          return this;
        }
      default:
        return this;
    }
   }

    /**
     * Allows the user to choose to play again after the game is decided with either a <code>WIN</code>
     * or <code>LOSS</code>.
     *
     * @return                            Returns the <code>COME_OUT</code> state so the user may
     *                                    play again.
     */
    public State playAgain() {
    if (this == WIN || this == LOSS ) {
      return COME_OUT;
    } else {
      return this;
    }
    }

    /**
     * Allows the user to surrender the game while in the <code>POINT</code> state (is not
     * currently implemented).
     *
     * @return                      <code>TERMINAL</code> state is returned.
     */
    public State surrender() {
    if (this != COME_OUT) {
      return TERMINAL;
    } else {
      return this;
    }
    }
  }

}
